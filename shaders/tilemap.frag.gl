smooth in vec2 pixelCoord;

uniform vec4 uniformColor = vec4(0,0,0,0);
uniform double time;

out vec4 result;

uniform TextBuf buf;
uniform FontDef font[8];

vec4 gamma(vec4 fragColor, float g) {
    vec4 result;
    result.r = pow(fragColor.r, g);
    result.g = pow(fragColor.g, g);
    result.b = pow(fragColor.b, g);
    result.a = fragColor.a;
    return result;
}

vec4 decodeColor(U16 c_) {
    int c = int(c_);
    float a = ((c >> 12) & 15) / 15.0f;
    float r = ((c >> 8) & 15) / 15.0f;
    float g = ((c >> 4) & 15) / 15.0f;
    float b = ((c >> 0) & 15) / 15.0f;
    return vec4(r,g,b,a);
}

vec4 sampleFont(U16 data, vec2 cellPixel) {
    if (data == 0u) { return vec4(0, 0, 0, 0); }
    uint tex = uint(data >> 12);
    uint chr = data & 0xFFFu;

    uvec2 tileCount = uvec2(font[tex].tileCount);
    uint m = uint(tileCount.x * tileCount.y - 1);
    chr = clamp(chr, 0, m);

    uvec2 chrCell = uvec2(chr % tileCount.x, chr / tileCount.x);
    vec2 cellUv = clamp((cellPixel * font[tex].tileScale + font[tex].tileOffset) / font[tex].tileSize, 0.0, 1.0);

    vec2 chrTile = vec2(chrCell) + cellUv;
    vec2 chrPixel = chrTile * vec2(font[tex].tileSize + font[tex].tileGap) + font[tex].tileOrigin;
    vec2 uv = chrPixel / vec2(font[tex].fontSize);
    return textureLod(font[tex].texture, uv, 0);
}

Cell readScreenBuffer(uvec2 cell) {
    if (cell.x < 0 || cell.y < 0 || cell.x > buf.bufferSize.x || cell.y > buf.bufferSize.y) {
        Cell result = defaultCell;
        return result;
    } else {
        Cell result = cellData[cell.x + cell.y * buf.bufferSize.x];
        return result;
    }
}

vec4 decodeCell(Cell cell, vec2 cellPixel) {
    vec4 font = sampleFont(cell.data, cellPixel);
    return font;

    // The value alpha blends between the background and foreground
    // FG = 0xBG = 0x0FFF for alpha passthrough
    vec4 bg = decodeColor(cell.bg);
    vec4 fg = decodeColor(cell.fg);
    vec4 r = mix(bg, fg, vec4(font.a));
    r.rgb *= font.rgb;
    return r;
}

vec4 sample_cell(uvec2 cell, vec2 cellPixel) {
    Cell bufferCell = readScreenBuffer(cell);

    vec4 result = decodeCell(bufferCell, cellPixel);
    return result;
}

vec4 sample_pixel(vec2 coord, out uvec2 cellIndex, out vec2 cellPixel) {
    vec2 cell = coord / vec2(buf.cellSize) - buf.cellOffset;
    cellIndex = uvec2(floor(cell));
    cellPixel = fract(cell) * vec2(buf.cellSize);
    vec4 result = sample_cell(cellIndex, cellPixel);
    return result;
}

void main()
{
    uvec2 cellIndex;
    vec2 cellPixel;

    result = sample_pixel(pixelCoord, cellIndex, cellPixel);

    if (cellIndex.x == buf.cursorPos.x && cellIndex.y == buf.cursorPos.y) {
        vec2 q = abs(cellPixel - 0.5f);
        if (q.x > 0.4f || q.y > 0.4f) {
            float lim = sin(float(6.283f * fract(time))) * 0.5f + 0.5f;
 
            result = vec4(buf.cursorColor, lim);
        }
    }

    //result.gb = cellPixel;
    //result.ra = vec2(0.5, 1);

}
